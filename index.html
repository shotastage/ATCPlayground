<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tokyu 5050 ATC Sim + LookAhead</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --bg-color: #101010;
            --panel-color: #202020;
            --text-color: #fff;
            --accent-color: #da0442; 
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* --- 路線図 --- */
        #route-info {
            flex: 2;
            background: #1a1a1a;
            position: relative;
            border-bottom: 2px solid #333;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }
        #line-indicator { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .line-badge { font-size: 12px; font-weight: bold; padding: 2px 8px; border-radius: 2px; }
        .station-info { display: flex; justify-content: space-between; align-items: baseline; }
        .st-name { font-size: 22px; font-weight: bold; letter-spacing: 1px; }
        .next-label { font-size: 12px; color: #aaa; margin-right: 10px; }
        .dist-bar-bg { width: 100%; height: 10px; background: #333; margin-top: 10px; position: relative; border-radius: 5px; overflow: hidden; }
        .dist-bar-fill { height: 100%; background: #00b894; width: 0%; transition: width 0.1s linear; }
        #distance-text { text-align: right; font-family: 'Share Tech Mono', monospace; font-size: 24px; color: #00b894; margin-top: 5px; }
        #distance-text.near { color: #e74c3c; }

        /* --- コックピット --- */
        #cockpit {
            flex: 5;
            background: #151515;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #lcd-panel {
            position: relative;
            width: 320px;
            height: 320px;
            background: #000;
            border: 4px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        canvas { width: 100%; height: 100%; }

        #center-speed {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        #digital-val {
            font-family: 'Share Tech Mono', monospace;
            font-size: 60px;
            color: #fff;
            line-height: 1;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        #unit-label { font-size: 14px; color: #aaa; margin-top: -5px; }

        #atc-lamp-box {
            position: absolute; top: 20px; left: 20px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .indicator-lamp {
            width: 80px; padding: 4px; font-size: 12px; text-align: center;
            background: #222; color: #555; border: 1px solid #444; border-radius: 4px; font-weight: bold;
        }
        .indicator-lamp.active { background: #da0442; color: #fff; box-shadow: 0 0 10px #da0442; border-color: #ff5e89; }
        .indicator-lamp.active-green { background: #2ecc71; color: #fff; box-shadow: 0 0 10px #2ecc71; border-color: #27ae60; }

        /* --- マスコン --- */
        #mascon-area {
            flex: 3;
            background: #202020;
            border-top: 2px solid #444;
            padding: 10px;
            display: flex; flex-direction: column; align-items: center;
        }
        #notch-indicator {
            font-family: 'Share Tech Mono', monospace; font-size: 32px; font-weight: bold;
            background: #000; color: #fff; padding: 5px 40px; border: 2px solid #555;
            border-radius: 6px; margin-bottom: 15px; min-width: 120px; text-align: center;
        }
        .n-p { color: #00b894 !important; text-shadow: 0 0 5px #00b894; }
        .n-n { color: #fff !important; }
        .n-b { color: #e67e22 !important; text-shadow: 0 0 5px #e67e22; }
        .n-eb { color: #ff0000 !important; text-shadow: 0 0 10px #ff0000; }

        input[type=range] {
            -webkit-appearance: none; width: 95%; height: 60px;
            background: linear-gradient(90deg, #c0392b 0%, #e67e22 30%, #7f8c8d 50%, #2980b9 70%, #2ecc71 100%);
            border-radius: 30px; outline: none; border: 4px solid #111;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 50px; height: 50px; border-radius: 50%;
            background: #ecf0f1; border: 4px solid #95a5a6; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }

        /* オーバーレイ */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;
        }
        #overlay h2 { font-size: 24px; margin-bottom: 10px; color: #fff; }
        #overlay p { color: #ccc; margin-bottom: 20px; }
        #btn-start {
            padding: 15px 40px; font-size: 20px; background: var(--accent-color); color: #fff;
            border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
        }
        #score-display { font-size: 20px; font-weight: bold; margin-bottom: 20px; min-height: 30px; }
    </style>
</head>
<body>

    <div id="route-info">
        <div id="line-indicator">
            <span class="line-badge" id="line-badge" style="background:#00418e;">MM線</span>
            <span style="font-size:12px; color:#aaa;">Next Station</span>
        </div>
        <div class="station-info">
            <div>
                <span class="next-label">次は</span>
                <span class="st-name" id="next-st-name">元町・中華街</span>
            </div>
            <div id="distance-text">0m</div>
        </div>
        <div class="dist-bar-bg">
            <div class="dist-bar-fill" id="dist-bar"></div>
        </div>
    </div>

    <div id="cockpit">
        <div id="lcd-panel">
            <canvas id="speedGraph" width="320" height="320"></canvas>
            <div id="center-speed">
                <div id="digital-val">0</div>
                <div id="unit-label">km/h</div>
            </div>
            <div id="atc-lamp-box">
                <div class="indicator-lamp" id="lamp-atc">ATC</div>
                <div class="indicator-lamp" id="lamp-p">P</div> <div class="indicator-lamp" id="lamp-b">B</div>
            </div>
        </div>
    </div>

    <div id="mascon-area">
        <div id="notch-indicator" class="n-n">N</div>
        <input type="range" id="mascon" min="-5" max="4" value="0" step="1">
        <div style="display:flex; justify-content:space-between; width:90%; font-size:10px; color:#888; margin-top:5px;">
            <span>EB</span>
            <span>B4</span>
            <span>N</span>
            <span>P4</span>
        </div>
    </div>

    <div id="overlay">
        <h2 id="ov-title">Tokyu 5050 ATC Sim</h2>
        <div id="score-display"></div>
        <p id="ov-desc">前方予告(Look-Ahead)機能搭載版<br>画面タップで開始</p>
        <button id="btn-start">運転開始</button>
    </div>

<script>
    // --- 定数 ---
    const STATIONS = [
        { name: "元町・中華街", dist: 0, line: "みなとみらい線", color: "#00418e" },
        { name: "日本大通り", dist: 800, line: "みなとみらい線", color: "#00418e" },
        { name: "馬車道", dist: 600, line: "みなとみらい線", color: "#00418e" },
        { name: "みなとみらい", dist: 700, line: "みなとみらい線", color: "#00418e" },
        { name: "新高島", dist: 800, line: "みなとみらい線", color: "#00418e" },
        { name: "横浜", dist: 1000, line: "東横線", color: "#da0442" },
        { name: "反町", dist: 900, line: "東横線", color: "#da0442" },
        { name: "東白楽", dist: 800, line: "東横線", color: "#da0442" },
        { name: "白楽", dist: 700, line: "東横線", color: "#da0442" },
        { name: "妙蓮寺", dist: 1000, line: "東横線", color: "#da0442" },
        { name: "菊名", dist: 1200, line: "東横線", color: "#da0442" },
        { name: "渋谷", dist: 1200, line: "東横線", color: "#da0442" } // 簡略化
    ];

    // ATCパターン定義 [距離(m)未満, 制限速度]
    // 順番は距離が小さい順（ゴールに近い順）
    const ATC_PATTERN = [
        { d: 15, v: 0 },
        { d: 100, v: 30 },
        { d: 200, v: 45 },
        { d: 300, v: 55 },
        { d: 450, v: 65 },
        { d: 600, v: 80 },
        { d: 850, v: 100 },
        { d: 99999, v: 110 }
    ];

    const MAX_SPEED_DISPLAY = 140; 
    const ACCEL_RATE = 3.3 / 4; 
    const BRAKE_RATE = 4.0 / 4; 
    const EB_RATE = 6.0;
    const FRICTION = 0.02;

    // Audio
    let audioCtx;
    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
    }
    function playATCChime() {
        if (!audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1800, t); 
        osc.frequency.exponentialRampToValueAtTime(1000, t + 0.2); 
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.2, t + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
        osc.start(t);
        osc.stop(t + 0.4);
    }

    // State
    let stIndex = 0;
    let distNext = 0;
    let totalDist = 0;
    let speed = 0; 
    let notch = 0;
    let atcLimit = 0;
    let nextAtcLimit = 110; // 前方予告用
    let isAtcBrake = false;
    let isStopped = true;
    let animationId;

    // DOM
    const cvs = document.getElementById('speedGraph');
    const ctx = cvs.getContext('2d');
    const elDigi = document.getElementById('digital-val');
    const elMascon = document.getElementById('mascon');
    const elNotch = document.getElementById('notch-indicator');
    const elNextSt = document.getElementById('next-st-name');
    const elLineBadge = document.getElementById('line-badge');
    const elDistText = document.getElementById('distance-text');
    const elDistBar = document.getElementById('dist-bar');
    const lampAtc = document.getElementById('lamp-atc');
    const lampP = document.getElementById('lamp-p');
    const lampB = document.getElementById('lamp-b');
    const overlay = document.getElementById('overlay');
    const ovTitle = document.getElementById('ov-title');
    const ovDesc = document.getElementById('ov-desc');
    const btnStart = document.getElementById('btn-start');
    const scoreDisp = document.getElementById('score-display');

    // Init
    setupStation(0);

    btnStart.addEventListener('click', () => {
        if(!audioCtx) initAudio();
        overlay.style.display = 'none';
        scoreDisp.textContent = "";
        
        if(stIndex >= STATIONS.length -1) return;

        isStopped = false;
        atcLimit = 30; 
        playATCChime();
        lastTime = performance.now();
        loop();
    });

    elMascon.addEventListener('input', (e) => {
        notch = parseInt(e.target.value);
        updateNotchUI(notch);
    });

    function updateNotchUI(val) {
        let txt = "N";
        let cls = "n-n";
        lampB.classList.remove('active'); // 黄色ランプ消す
        
        // Pランプは前方予告で使用したいのでここではノッチ連動しない方がリアルだが、
        // 今回は「P」=パターン接近、「B」=ブレーキ中として使う
        
        if(val > 0) {
            txt = "P" + val;
            cls = "n-p";
        } else if (val < 0) {
            lampB.classList.add('active'); // ブレーキ時にB点灯
            if (val === -5) {
                txt = "EB";
                cls = "n-eb";
            } else {
                txt = "B" + Math.abs(val);
                cls = "n-b";
            }
        }
        elNotch.textContent = txt;
        elNotch.className = "";
        elNotch.classList.add(cls);
    }

    function setupStation(idx) {
        stIndex = idx;
        isStopped = true;
        speed = 0;
        notch = 0;
        elMascon.value = 0;
        updateNotchUI(0);
        isAtcBrake = false;

        if (idx < STATIONS.length - 1) {
            const next = STATIONS[idx+1];
            distNext = next.dist;
            totalDist = next.dist;
            elNextSt.textContent = next.name;
            elLineBadge.textContent = (next.line === "東横線") ? "TY 東横線" : "MM みなとみらい線";
            elLineBadge.style.backgroundColor = next.color;
            ovTitle.textContent = STATIONS[idx].name + " 停車中";
            ovDesc.innerHTML = "次は " + next.name + " です。<br>出発ボタンを押してください。";
            btnStart.style.display = "inline-block";
            overlay.style.display = "flex";
        } else {
            elNextSt.textContent = "終点";
            ovTitle.textContent = "全区間 走破！";
            ovDesc.textContent = "お疲れ様でした。";
            btnStart.style.display = "none";
            overlay.style.display = "flex";
        }
        draw();
    }

    let lastTime = 0;
    function loop() {
        if(isStopped) return;
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        updatePhysics(dt);
        updateATC();
        updateUI();
        draw();
        animationId = requestAnimationFrame(loop);
    }

    function updatePhysics(dt) {
        let accel = 0;
        if(notch > 0) accel = notch * ACCEL_RATE;
        else if(notch < 0) {
            if(notch === -5) accel = -EB_RATE;
            else accel = notch * BRAKE_RATE;
        }

        if(speed > atcLimit + 1.0) { 
            isAtcBrake = true;
            if(accel > -4.0) accel = -4.5;
        } else {
            isAtcBrake = false;
        }

        if(speed > 0) accel -= FRICTION;
        speed += accel * dt;
        if(speed < 0) speed = 0;

        const mps = speed / 3.6;
        distNext -= mps * dt;

        if(speed < 0.1 && notch <= 0 && Math.abs(distNext) < 60 && !isStopped) {
            speed = 0;
            finishStop();
        }
    }

    // ★重要: 前方予告ロジック
    function updateATC() {
        let currentLim = 110;
        let nextLim = 110;

        // 1. 現在位置の制限速度を探す
        for (let i = 0; i < ATC_PATTERN.length; i++) {
            if (distNext < ATC_PATTERN[i].d) {
                currentLim = ATC_PATTERN[i].v;
                
                // 2. 次の区間の制限速度（さらに距離が短い方の設定）を取得
                // もし i-1 が存在すれば、それが次の制限
                if (i > 0) {
                    nextLim = ATC_PATTERN[i-1].v;
                } else {
                    nextLim = 0; // 最後は0
                }
                break;
            }
        }

        // 音を鳴らす（現在制限が変わった時）
        if(currentLim !== atcLimit) {
            atcLimit = currentLim;
            playATCChime();
        }

        // 予告速度の更新
        nextAtcLimit = nextLim;
    }

    function finishStop() {
        isStopped = true;
        cancelAnimationFrame(animationId);
        const dist = Math.floor(distNext);
        let msg = "", col = "";
        if(Math.abs(dist) <= 2) { msg = "Just Stop! 誤差 " + dist + "m"; col = "#2ecc71"; }
        else if (dist > 0) { msg = "手前停車 残り " + dist + "m"; col = "#f1c40f"; }
        else { msg = "オーバーラン " + Math.abs(dist) + "m"; col = "#e74c3c"; }
        scoreDisp.textContent = msg;
        scoreDisp.style.color = col;
        setTimeout(() => { setupStation(stIndex + 1); }, 2000);
    }

    function updateUI() {
        elDigi.textContent = Math.floor(speed);
        let d = Math.floor(distNext);
        elDistText.textContent = d + "m";
        if(d < 100) elDistText.classList.add('near');
        else elDistText.classList.remove('near');
        
        let p = 0;
        if(totalDist > 0) p = 100 - (distNext / totalDist * 100);
        if(p < 0) p = 0; if(p > 100) p = 100;
        elDistBar.style.width = p + "%";

        // ランプ制御
        if(isAtcBrake) {
            lampAtc.classList.add('active');
        } else {
            lampAtc.classList.remove('active');
        }

        // Pランプ（前方予告が現在の制限より低い場合、減速準備として点灯させる）
        if (nextAtcLimit < atcLimit && speed > nextAtcLimit) {
            lampP.classList.add('active-green'); // 緑色で点灯
        } else {
            lampP.classList.remove('active-green');
        }
    }

    function draw() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        const cx = cvs.width / 2, cy = cvs.height / 2, r = 140;
        const startDeg = 135, endDeg = 405, toRad = Math.PI / 180;

        for (let i = 0; i <= MAX_SPEED_DISPLAY; i += 2) {
            const ratio = i / MAX_SPEED_DISPLAY;
            const deg = startDeg + ratio * (endDeg - startDeg);
            const rad = deg * toRad;
            const isMain = (i % 20 === 0), isSub = (i % 10 === 0);
            let len = isMain ? 15 : (isSub ? 10 : 5);
            
            let tickColor = "#fff";
            // 超過時は目盛りも赤くする
            if(i > atcLimit && speed > atcLimit) tickColor = "#500";
            
            const x1 = cx + Math.cos(rad) * (r - len);
            const y1 = cy + Math.sin(rad) * (r - len);
            const x2 = cx + Math.cos(rad) * r;
            const y2 = cy + Math.sin(rad) * r;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = tickColor;
            ctx.lineWidth = isMain ? 3 : (isSub ? 2 : 1);
            ctx.stroke();

            if (isMain) {
                const tx = cx + Math.cos(rad) * (r - 35);
                const ty = cy + Math.sin(rad) * (r - 35);
                ctx.fillStyle = "#fff";
                ctx.font = "bold 16px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(i, tx, ty);
            }
        }

        // --- 予告マーカー（枠線のみの三角：Next Limit） ---
        // 次の制限が現在の制限より低い場合のみ表示
        if (nextAtcLimit < atcLimit && nextAtcLimit >= 0) {
            drawTriangle(cx, cy, r, nextAtcLimit, false);
        }

        // --- 本現示マーカー（塗りつぶし三角：Current Limit） ---
        drawTriangle(cx, cy, r, atcLimit, true);

        // --- 超過帯（赤） ---
        if (speed > atcLimit) {
            const limRatio = atcLimit / MAX_SPEED_DISPLAY;
            const spdRatio = Math.min(speed, MAX_SPEED_DISPLAY) / MAX_SPEED_DISPLAY;
            const limAng = (startDeg + limRatio * (endDeg - startDeg)) * toRad;
            const spdAng = (startDeg + spdRatio * (endDeg - startDeg)) * toRad;
            ctx.beginPath();
            ctx.arc(cx, cy, r - 5, limAng, spdAng, false);
            ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
            ctx.lineWidth = 10;
            ctx.stroke();
        }

        // --- 針 ---
        const spdRatio = speed / MAX_SPEED_DISPLAY;
        const spdDeg = startDeg + spdRatio * (endDeg - startDeg);
        const spdRad = spdDeg * toRad;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(spdRad);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(r - 10, 0);
        ctx.strokeStyle = (speed > atcLimit && atcLimit > 0) ? "#ff0000" : "#fff";
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.shadowBlur = 5;
        ctx.shadowColor = (speed > atcLimit && atcLimit > 0) ? "red" : "white";
        ctx.stroke();
        ctx.restore();

        ctx.beginPath();
        ctx.arc(cx, cy, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#333";
        ctx.fill();
    }

    function drawTriangle(cx, cy, r, val, isSolid) {
        if(val > MAX_SPEED_DISPLAY) return;
        const startDeg = 135, endDeg = 405, toRad = Math.PI / 180;
        const ratio = val / MAX_SPEED_DISPLAY;
        const deg = startDeg + ratio * (endDeg - startDeg);
        const rad = deg * toRad;
        
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rad);
        ctx.beginPath();
        // 外側から内側へ向く三角
        ctx.moveTo(r + 5, 0);
        ctx.lineTo(r + 25, -10);
        ctx.lineTo(r + 25, 10);
        ctx.closePath();
        
        if (isSolid) {
            ctx.fillStyle = "#ff8c00"; // オレンジ塗りつぶし
            ctx.fill();
        } else {
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ff8c00"; // オレンジ枠線
            ctx.stroke();
            // 中は黒で塗りつぶして針が見やすくする
            ctx.fillStyle = "#000"; 
            ctx.fill();
        }
        ctx.restore();
    }
</script>
</body>
</html>